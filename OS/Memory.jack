/** OS Memory operations 
 *	Author: RiVeRx
 *	Date: 22.03.2021 
 */
class Memory {
	static Array ram;
	static Array heap;
	static int deAllocValue;
	
	function void init() {
		let ram = 0; 		// Initialize ram hack.
		let heap = 2048; // heapBase
		let deAllocValue = -31416;
		let heap[0] = deAllocValue;	// next
		let heap[1] = 14335;// length
		return;
	}
	
	/** Returns the value of the given RAM address */
	function int peek(int address) {
		return ram[address];
	}
	
	/** Sets the value of the given RAM address to the given value */
	function void poke(int address, int value) {
		let ram[address] = value;
		return;
	}
	
	/** Finds and allocates from the heap a memory block of the
		specified size and returns a reference to it's base address */
	function Array alloc(int size) {
		var int freeSegment;
		if (~(size > 0)) { do Sys.error(5); } // Allocated memory size must be positive.
		let freeSegment = firstFit(size + 2);
		if (freeSegment = 0) { do Sys.error(6); }  // Heap overflow.
		return freeSegment;
	}
	
	/** Finds the first block fit for allocating memory */
	function int firstFit(int size) {
		var int freeListPtr, block, lastPtr;
		var int listAvailableSize, possibleSize;
		let freeListPtr = heap;
		let lastPtr = heap;
		while (~(freeListPtr = deAllocValue)) {
			let listAvailableSize = ram[freeListPtr+1];
			if (~(listAvailableSize < size)) {
			    // Calculate new block address.
				let block = freeListPtr + 2 + listAvailableSize - size;
				if (~(listAvailableSize = size)) { // if size doesn't fit.
				    // Separate block into two.
                    let ram[freeListPtr+1] = listAvailableSize - size;
                    let ram[block-1] = size;
                    let ram[block-2] = deAllocValue;
				} else { // if size fits.
				    // remove block from list
				    let ram[lastPtr] = ram[freeListPtr];
				}
				return block;
			} else {
			    // if size of block not enough
			    let lastPtr = freeListPtr; // remember last ptr
				let freeListPtr = ram[freeListPtr]; // go to the next block
			}
		}
		return 0; // We can't find free block.
	}

    /** Finds the minimal fits block for allocating memory */
	function int bestFit(int size) {
	    return 0;
	}
	
	/** De-allocates the given object and frees it's space */
	function void deAlloc(Array o) {
		// Append o to the freeList
		var int blockBase, blockSize, freeListPtr, freeSize, lastPtr, lastSize;
		let blockBase = o - 2;
		let blockSize = ram[blockBase+1];
		let freeListPtr = heap;
		let lastPtr = heap;
		// While address is less then blockBase or we not found end of list.
		while ((freeListPtr < blockBase) & (~(freeListPtr = deAllocValue))) {
		    let lastPtr = freeListPtr;
		    let freeListPtr = ram[freeListPtr];
		}
		if (freeListPtr > blockBase) {
		    // If block are contiguous - merge
		    let lastSize = ram[lastPtr+1];
		    let freeSize = ram[freeListPtr+1];
		    // Try merge block with next segment.
            if ((blockBase + blockSize) = freeListPtr) {
                let ram[blockBase+1] = ram[blockBase+1] + ram[freeListPtr+1] + 2;
                let ram[blockBase] = ram[freeListPtr];
            }
		    // Try merge block with previous segment.
		    if (lastPtr + lastSize = blockBase) {
		        let ram[lastPtr+1] = lastSize + ram[blockBase+1]; // Change the size of freeBlock.
            } else {
                // Insert a fragment block between two
                let ram[lastPtr] = blockBase;
                let ram[blockBase] = freeListPtr;
            }
		} else {
		    // Insert in the end of list
		    let ram[lastPtr] = blockBase;
		    let ram[blockBase] = deAllocValue;
		}
		return;
	}
}